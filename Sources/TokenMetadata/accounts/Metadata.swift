/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita-swift
 */
import Foundation
import Beet
import BeetSolana
import Solana


/**
* Arguments used to create {@link Metadata}
* @category Accounts
* @category generated
*/
public protocol MetadataArgs {
    var metadataDiscriminator: [UInt8] { get }
     var key: Key { get }
     var updateAuthority: PublicKey { get }
     var mint: PublicKey { get }
     var data: Data { get }
     var primarySaleHappened: Bool { get }
     var isMutable: Bool { get }
     var editionNonce: COption<UInt8> { get }
     var tokenStandard: COption<TokenStandard> { get }
     var collection: COption<Collection> { get }
     var uses: COption<Uses> { get }
     var collectionDetails: COption<CollectionDetails> { get }
}

/**
 * Holds the data for the {@link Metadata} Account and provides de/serialization
 * functionality for that data
 *
 * @category Accounts
 * @category generated
 */
public struct Metadata: MetadataArgs {
  public static let metadataDiscriminator = [72, 11, 121, 26, 111, 181, 85, 93] as [UInt8]

  public let metadataDiscriminator: [UInt8]
  public let key: Key
  public let updateAuthority: PublicKey
  public let mint: PublicKey
  public let data: Data
  public let primarySaleHappened: Bool
  public let isMutable: Bool
  public let editionNonce: COption<UInt8>
  public let tokenStandard: COption<TokenStandard>
  public let collection: COption<Collection>
  public let uses: COption<Uses>
  public let collectionDetails: COption<CollectionDetails>

  /**
   * Creates a {@link Metadata} instance from the provided args.
   */
  public static func fromArgs(args: Args) -> Metadata {
    return Metadata(
        metadataDiscriminator: args["accountDiscriminator"] as! [UInt8],
        key: args["key"] as! Key,
        updateAuthority: args["updateAuthority"] as! PublicKey,
        mint: args["mint"] as! PublicKey,
        data: args["data"] as! Data,
        primarySaleHappened: args["primarySaleHappened"] as! Bool,
        isMutable: args["isMutable"] as! Bool,
        editionNonce: args["editionNonce"] as! COption<UInt8>,
        tokenStandard: args["tokenStandard"] as! COption<TokenStandard>,
        collection: args["collection"] as! COption<Collection>,
        uses: args["uses"] as! COption<Uses>,
        collectionDetails: args["collectionDetails"] as! COption<CollectionDetails>
    )
  }
  /**
   * Deserializes the {@link Metadata} from the data of the provided {@link web3.AccountInfo}.
   * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
   */
  public static func fromAccountInfo(
    accountInfo: Foundation.Data,
    offset:Int=0
  ) -> ( Metadata, Int )  {
    return Metadata.deserialize(buf: accountInfo, offset: offset)
  }
  /**
   * Retrieves the account info from the provided address and deserializes
   * the {@link Metadata} from its data.
   *
   * @throws Error if no account info is found at the address or if deserialization fails
   */
  public static func fromAccountAddress(
    connection: Api,
    address: PublicKey,
    onComplete: @escaping (Result<Metadata, Error>) -> Void
  ) {
    connection.getAccountInfo(account: address.base58EncodedString) { result in
        switch result {
            case .success(let pureData):
                if let data = pureData.data?.value {
                    onComplete(.success(Metadata.deserialize(buf: data).0))
                } else {
                    onComplete(.failure(SolanaError.nullValue))
                }
            case .failure(let error):
                onComplete(.failure(error))
        }
    }
  }
  /**
   * Deserializes the {@link Metadata} from the provided data Buffer.
   * @returns a tuple of the account data and the offset up to which the buffer was read to obtain it.
   */
  public static func deserialize(
    buf: Foundation.Data,
    offset: Int = 0
  ) -> ( Metadata, Int ) {
    return metadataBeet.deserialize(buffer: buf, offset: offset)
  }
  /**
   * Serializes the {@link Metadata} into a Buffer.
   * @returns a tuple of the created Buffer and the offset up to which the buffer was written to store it.
   */
  public func serialize() -> ( Foundation.Data, Int ) {
    return metadataBeet.serialize(instance: [
        "metadataDiscriminator" : self.metadataDiscriminator,
        "key" : self.key,
        "updateAuthority" : self.updateAuthority,
        "mint" : self.mint,
        "data" : self.data,
        "primarySaleHappened" : self.primarySaleHappened,
        "isMutable" : self.isMutable,
        "editionNonce" : self.editionNonce,
        "tokenStandard" : self.tokenStandard,
        "collection" : self.collection,
        "uses" : self.uses,
        "collectionDetails" : self.collectionDetails
        ])
  }
  /**
* Returns the byteSize of a {@link Buffer} holding the serialized data of
* {@link Metadata} for the provided args.
*
* @param args need to be provided since the byte size for this account
* depends on them
*/
static func byteSize(args: MetadataArgs) -> UInt64 {
    return UInt64(metadataBeet.toFixedFromValue(val: args).byteSize)
}
/**
* Fetches the minimum balance needed to exempt an account holding
* {@link Metadata} data from rent
*
* @param args need to be provided since the byte size for this account
* depends on them
* @param connection used to retrieve the rent exemption information
*/
static func getMinimumBalanceForRentExemption(
    args: MetadataArgs,
    connection: Api,
    commitment: Commitment?,
    onComplete: @escaping(Result<UInt64, Error>) -> Void
) {
    return connection.getMinimumBalanceForRentExemption(dataLength: Metadata.byteSize(args: args), commitment: commitment, onComplete: onComplete)
}
}
  /**
   * @category Accounts
   * @category generated
   */
  public let metadataBeet = FixableBeetStruct<Metadata>(
    fields:[
        ("accountDiscriminator", Beet.fixedBeet(.init(value: .collection(UniformFixedSizeArray<UInt8>(element: .init(value: .scalar(u8())), len: 8))))),
        ("key", keyBeetWrapped),
        ("updateAuthority", Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))),
        ("mint", Beet.fixedBeet(.init(value: .scalar(BeetPublicKey())))),
        ("data", dataBeetWrapped),
        ("primarySaleHappened", Beet.fixedBeet(.init(value: .scalar(bool())))),
        ("isMutable", Beet.fixedBeet(.init(value: .scalar(bool())))),
        ("editionNonce", Beet.fixableBeat(coption(inner: Beet.fixedBeet(.init(value: .scalar(u8())))))),
        ("tokenStandard", Beet.fixableBeat(coption(inner: tokenStandardBeetWrapped))),
        ("collection", Beet.fixableBeat(coption(inner: collectionBeetWrapped))),
        ("uses", Beet.fixableBeat(coption(inner: usesBeetWrapped))),
        ("collectionDetails", Beet.fixableBeat(coption(inner: collectionDetailsBeetWrapped)))
    ],
    construct: Metadata.fromArgs,
    description: "Metadata"
)
